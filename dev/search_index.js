var documenterSearchIndex = {"docs":
[{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [\n    AlgebraicOptimization.CompositionalProgramming.Objectives,\n    AlgebraicOptimization.CompositionalProgramming.Optimizers,\n    AlgebraicOptimization.CompositionalProgramming.OpenFlowGraphs,\n    AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras\n]\nPrivate = false","category":"page"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.Objectives.MinObj","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.Objectives.MinObj","text":" MinObj\n\nFinset-algebra implementing composition of minimization problems by variable sharing.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.Objectives.PrimalObjective","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.Objectives.PrimalObjective","text":"PrimalObjective\n\nAn objective defining a minimization problems. These consist of a finset representing the decision variables and a cost function on the decision space. Note the cost function should be autodifferentiable by ForwardDiff.jl.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.Objectives.gradient_flow-Tuple{Open{PrimalObjective}}","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.Objectives.gradient_flow","text":" gradient_flow(f::Open{PrimalObjective})\n\nReturns the gradient flow optimizer of a given primal objective.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.Optimizers.Optimizer","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.Optimizers.Optimizer","text":"Optimizer\n\nAn optimizer is defined by a finite set N representing the state space and a function Rᴺ → Rᴺ representing the dynamics.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.Optimizers.pullback_matrix-Tuple{Catlab.CategoricalAlgebra.Sets.SetFunction{Dom, Codom} where {S, S′, Dom<:(Catlab.CategoricalAlgebra.FinSets.FinSet{S}), Codom<:(Catlab.CategoricalAlgebra.FinSets.FinSet{S′})}}","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.Optimizers.pullback_matrix","text":" pullback_matrix(f::FinFunction)\n\nThe pullback of f : n → m is the linear map f^* : Rᵐ → Rⁿ defined by f^*(y)[i] = y[f(i)].\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.Optimizers.pushforward_matrix-Tuple{Catlab.CategoricalAlgebra.Sets.SetFunction{Dom, Codom} where {S, S′, Dom<:(Catlab.CategoricalAlgebra.FinSets.FinSet{S}), Codom<:(Catlab.CategoricalAlgebra.FinSets.FinSet{S′})}}","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.Optimizers.pushforward_matrix","text":" pushforward_matrix(f::FinFunction)\n\nThe pushforward is the dual of the pullback.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.CospanAlgebra","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.CospanAlgebra","text":" CospanAlgebra{T}\n\nA cospan-algebra is a lax symmetric monoidal functor (Cospan(FinSet),+) → (Set,×).\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.FinSetAlgebra","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.FinSetAlgebra","text":" FinSetAlgebra{T}\n\nA finset algebra is a lax symmetric monoidal functor (FinSet,+) → (Set,×). We implicitly use the category of Julia types and (pure) functions as a model of Set, so T is the type of objects mapped to by the algebra. Finset algebras must then implement the hom_map and laxator methods.\n\nT must implement dom(x::T)::FinSet, which implicitly defines the object map of a finset-algebra.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.Open","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.Open","text":" Open{T}\n\nGiven a type T which implements finset-algebra, Open{T} implements cospan-algebra. o::T is an object, S is the domain of o, and m : dom(m) → S specifies which parts of S are open for composition.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.hom_map-Union{Tuple{T}, Tuple{FinSetAlgebra{T}, Catlab.CategoricalAlgebra.Sets.SetFunction{Dom, Codom} where {S, S′, Dom<:(Catlab.CategoricalAlgebra.FinSets.FinSet{S}), Codom<:(Catlab.CategoricalAlgebra.FinSets.FinSet{S′})}, T}} where T","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.hom_map","text":" hom_map(::FinSetAlgebra{T}, ϕ::FinFunction, X::T)::T where T\n\nOverload to implement the action of a finset-algebra on morphisms.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.laxator-Union{Tuple{T}, Tuple{FinSetAlgebra{T}, Vector{T}}} where T","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.laxator","text":" laxator(::FinSetAlgebra{T}, Xs::Vector{T})::T where T\n\nOverload to implement the product comparison (aka laxator) of a finset algebra.\n\n\n\n\n\n","category":"method"},{"location":"#AlgebraicOptimization.jl","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"","category":"section"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"CurrentModule = AlgebraicOptimization","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"This package is designed for building large optimization problems out of simpler subproblems and automatically compiling them to a distributed solver.","category":"page"},{"location":"#Basic-Usage","page":"AlgebraicOptimization.jl","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"The most simple use of this package is making and solving a composite optimization problem. For example, say we have three subproblems whose objectives are given by some random quadratic cost functions:","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"using AlgebraicOptimization\nusing Catlab\n\n# Problem parameters.\nP = [2.1154  -0.3038   0.368   -1.5728  -1.203\n    -0.3038   1.5697   1.0226   0.159   -0.946\n     0.368    1.0226   1.847   -0.4916  -1.2668\n    -1.5728   0.159   -0.4916   2.2192   1.5315\n    -1.203   -0.946   -1.2668   1.5315   1.9281]\nQ = [0.2456   0.3564  -0.0088\n     0.3564   0.5912  -0.0914\n    -0.0088  -0.0914   0.8774]\nR = [2.0546  -1.333   -0.5263   0.3189\n    -1.333    1.0481  -0.0211   0.2462\n    -0.5263  -0.0211   0.951   -0.7813\n     0.3189   0.2462  -0.7813   1.5813]\n\na = [-0.26, 0.22, 0.09, 0.19, -0.96]\nb = [-0.72, 0.12, 0.41]\nc = [0.55, 0.51, 0.6, -0.61]\n\n# Subproblem objectives.\n# A PrimalObjective wraps an objective function with its input dimension.\nf = PrimalObjective(FinSet(5),x->x'*P*x + a'*x)\ng = PrimalObjective(FinSet(3),x->x'*Q*x + b'*x)\nh = PrimalObjective(FinSet(4),x->x'*R*x + c'*x)","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"Now, to compose these subproblems, we need to make them into open problems. An open problem specifies which components of a problem's domain are open to composition with other problems. We do this as follows:","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"# Make open problems.\n# The first argument is the primal objective we are wrapping, the second argument is a function\n# specifying which components of the objective are exposed. \np1 = Open{PrimalObjective}(FinSet(5), PrimalObjective(FinSet(5),f), FinFunction([2,4], 5))\np2 = Open{PrimalObjective}(FinSet(3), PrimalObjective(FinSet(3),g), id(FinSet(3)))\np3 = Open{PrimalObjective}(FinSet(4), PrimalObjective(FinSet(4),h), FinFunction([1,3,4]))","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"To specify the composition pattern of our subproblems, we use Catlab's relation macro to make an undirected wiring diagram and oapply to compose our subproblems.","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"d = @relation_diagram (x,y,z) begin\n    f(u,x)\n    g(u,w,y)\n    h(u,w,z)\nend\n\ncomposite_prob = oapply(d, [p1,p2,p3])","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"Now, we can solve the composite problem with distributed gradient descent:","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"# Arguments are problem, initial guess, step size, and number of iterations\nsol = solve(composite, repeat([100.0], dom(composite_prob).n), 0.1, 100)","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"Currently, we just support unconstrained and equality constrained problems with plans to add support for inequality constrained and disciplined convex programs.","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"More complete documentation and quality of life improvements are also on the way.","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"This package is an implementation of A Compositional Framework for First-Order Optimization.","category":"page"}]
}
