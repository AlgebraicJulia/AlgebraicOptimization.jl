var documenterSearchIndex = {"docs":
[{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.Objectives.MinObj","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.Objectives.MinObj","text":" MinObj\n\nFinset-algebra implementing composition of minimization problems by variable sharing.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.Objectives.PrimalObjective","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.Objectives.PrimalObjective","text":"PrimalObjective\n\nAn objective defining a minimization problems. These consist of a finset representing the decision variables and a cost function on the decision space. Note the cost function should be autodifferentiable by ForwardDiff.jl.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.Objectives.gradient_flow-Tuple{Open{PrimalObjective}}","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.Objectives.gradient_flow","text":" gradient_flow(f::Open{PrimalObjective})\n\nReturns the gradient flow optimizer of a given primal objective.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.Optimizers.Optimizer","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.Optimizers.Optimizer","text":"Optimizer\n\nAn optimizer is defined by a finite set N representing the state space and a function Rᴺ → Rᴺ representing the dynamics.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.Optimizers.pullback_matrix-Tuple{Catlab.CategoricalAlgebra.Sets.SetFunction{Dom, Codom} where {S, S′, Dom<:(Catlab.CategoricalAlgebra.FinSets.FinSet{S}), Codom<:(Catlab.CategoricalAlgebra.FinSets.FinSet{S′})}}","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.Optimizers.pullback_matrix","text":" pullback_matrix(f::FinFunction)\n\nThe pullback of f : n → m is the linear map f^* : Rᵐ → Rⁿ defined by f^*(y)[i] = y[f(i)].\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.Optimizers.pushforward_matrix-Tuple{Catlab.CategoricalAlgebra.Sets.SetFunction{Dom, Codom} where {S, S′, Dom<:(Catlab.CategoricalAlgebra.FinSets.FinSet{S}), Codom<:(Catlab.CategoricalAlgebra.FinSets.FinSet{S′})}}","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.Optimizers.pushforward_matrix","text":" pushforward_matrix(f::FinFunction)\n\nThe pushforward is the dual of the pullback.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.CospanAlgebra","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.CospanAlgebra","text":" CospanAlgebra{T}\n\nA cospan-algebra is a lax symmetric monoidal functor (Cospan(FinSet),+) → (Set,×).\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.FinSetAlgebra","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.FinSetAlgebra","text":" FinSetAlgebra{T}\n\nA finset algebra is a lax symmetric monoidal functor (FinSet,+) → (Set,×). We implicitly use the category of Julia types and (pure) functions as a model of Set, so T is the type of objects mapped to by the algebra. Finset algebras must then implement the hom_map and laxator methods.\n\nT must implement dom(x::T)::FinSet, which implicitly defines the object map of a finset-algebra.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.Open","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.Open","text":" Open{T}\n\nGiven a type T which implements finset-algebra, Open{T} implements cospan-algebra. o::T is an object, S is the domain of o, and m : dom(m) → S specifies which parts of S are open for composition.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.hom_map-Union{Tuple{T}, Tuple{FinSetAlgebra{T}, Catlab.CategoricalAlgebra.Sets.SetFunction{Dom, Codom} where {S, S′, Dom<:(Catlab.CategoricalAlgebra.FinSets.FinSet{S}), Codom<:(Catlab.CategoricalAlgebra.FinSets.FinSet{S′})}, T}} where T","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.hom_map","text":" hom_map(::FinSetAlgebra{T}, ϕ::FinFunction, X::T)::T where T\n\nOverload to implement the action of a finset-algebra on morphisms.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.laxator-Union{Tuple{T}, Tuple{FinSetAlgebra{T}, Vector{T}}} where T","page":"Library Reference","title":"AlgebraicOptimization.CompositionalProgramming.FinSetAlgebras.laxator","text":" laxator(::FinSetAlgebra{T}, Xs::Vector{T})::T where T\n\nOverload to implement the product comparison (aka laxator) of a finset algebra.\n\n\n\n\n\n","category":"method"},{"location":"generated/consensus_example/#Consensus-Example","page":"Consensus Example","title":"Consensus Example","text":"","category":"section"},{"location":"generated/consensus_example/","page":"Consensus Example","title":"Consensus Example","text":"For this example, the agents are to reach consensus in the x-axis while reaching individual tracking goals in the y-axis. Thus each agent’s subproblem is a linear quadratic tracking problem in y-space with a quadratic cost on the control activation.","category":"page"},{"location":"generated/consensus_example/","page":"Consensus Example","title":"Consensus Example","text":"The coordination sheaf is defined over a fully connected communication topology, where each restriction map is simply the projection onto the x coordinate. Edge potentials are the standard norm squared potential function encoding the consensus goal.","category":"page"},{"location":"generated/consensus_example/","page":"Consensus Example","title":"Consensus Example","text":"using Test\nusing AlgebraicOptimization\nusing LinearAlgebra\nusing BlockArrays\nusing Plots\nusing CSV, Tables\ninclude(\"../../../examples/paper-examples/PaperPlotting.jl\")\nusing .PaperPlotting","category":"page"},{"location":"generated/consensus_example/","page":"Consensus Example","title":"Consensus Example","text":"First, we set up each agent's dynamics according to the equation x' = Ax + Bu.","category":"page"},{"location":"generated/consensus_example/","page":"Consensus Example","title":"Consensus Example","text":"dt = 0.1  # Discretization step size\nA = [1 dt 0 0; 0 1 0 0; 0 0 1 dt; 0 0 0 1]\nB = [0 0; dt 0; 0 0; 0 dt]\nC = [1 0 0 0]\nsystem = DiscreteLinearSystem(A, B, C)","category":"page"},{"location":"generated/consensus_example/","page":"Consensus Example","title":"Consensus Example","text":"Second, we set up Q and R matrices for the quadratic objective function for each agent: x'Qx + u'Ru.","category":"page"},{"location":"generated/consensus_example/","page":"Consensus Example","title":"Consensus Example","text":"Q = I(4)\nQ[1, 1] = 0    # First variable is unconstrained\nR = I(2)","category":"page"},{"location":"generated/consensus_example/","page":"Consensus Example","title":"Consensus Example","text":"Third, set up system properties of time horoizon and control bounds.","category":"page"},{"location":"generated/consensus_example/","page":"Consensus Example","title":"Consensus Example","text":"N = 10\ncontrol_bounds = [-2.0, 2.0]\nparams1 = MPCParams(Q, R, system, control_bounds, N, [0, 0, 2.0, 0])\nparams2 = MPCParams(Q, R, system, control_bounds, N, [0, 0, 4.0, 0])\nparams3 = MPCParams(Q, R, system, control_bounds, N, [0, 0, 6.0, 0])","category":"page"},{"location":"generated/consensus_example/","page":"Consensus Example","title":"Consensus Example","text":"Fourth, we set up the communication pattern. For this example, we have a triangular connection pattern between the 3 agents. Each agent shares only its x coordinate with its neighbor.","category":"page"},{"location":"generated/consensus_example/","page":"Consensus Example","title":"Consensus Example","text":"c = CellularSheaf([4, 4, 4], [1, 1, 1])\nset_edge_maps!(c, 1, 2, 1, C, C)\nset_edge_maps!(c, 1, 3, 2, C, C)\nset_edge_maps!(c, 2, 3, 3, C, C)","category":"page"},{"location":"generated/consensus_example/","page":"Consensus Example","title":"Consensus Example","text":"Fifth, we set up the solver","category":"page"},{"location":"generated/consensus_example/","page":"Consensus Example","title":"Consensus Example","text":"x_init = BlockArray(5 * rand(-1:0.1:1, 12), c.vertex_stalks)\nprob = MultiAgentMPCProblem([params1, params2, params3], c, x_init)\nalg = ADMM(2.0, 10)\nnum_iters = 100","category":"page"},{"location":"generated/consensus_example/","page":"Consensus Example","title":"Consensus Example","text":"Finally, we run the solver, which outputs the optimized trajectory and controls for each agent.","category":"page"},{"location":"generated/consensus_example/","page":"Consensus Example","title":"Consensus Example","text":"trajectory, controls = do_mpc!(prob, alg, num_iters)\n\nPaperPlotting.plot_trajectories(trajectory, [1 0 0 0; 0 0 1 0])","category":"page"},{"location":"generated/flocking_example/#Flocking-Example","page":"Flocking Example","title":"Flocking Example","text":"","category":"section"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"For this example, agents implement the standard flocking goal of reaching consensus in velocities while staying a fixed distance away from all other agents. The constant sheaf underlineR^4 on a fully connected communication topology along with potential functions summing the stan- dard consensus potential function on the velocity components and the fixed distance potential function with r^2 = 5 on the position components. Each agents’ objective is to minimize total control activation. Additionally, a designated leader agent tracks a constant rightward velocity vector. The results of this controller run for 65 iterations are shown below. Computing the distance between each agent confirms that they reached the desired pairwise distance of sqrt5.","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"using Test\nusing AlgebraicOptimization\nusing LinearAlgebra\nusing BlockArrays\nusing Plots\ninclude(\"../../../examples/paper-examples/PaperPlotting.jl\")\nusing .PaperPlotting","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"Set up each agent's dynamics: x(t+1) = Ax(t) + Bu(t)","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"dt = 0.1 # Discretization step size\nA = [1 dt 0 0; 0 1 0 0; 0 0 1 dt; 0 0 0 1]\nB = [0 0; dt 0; 0 0; 0 dt]\nC = [1 0 0 0; 0 0 1 0]\nsystem = DiscreteLinearSystem(A, B, C)","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"Initialize the weight matrices such that the objective only concerns velocities","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"Q_leader = [0 0 0 0; 0 50 0 0; 0 0 0 0; 0 0 0 50]\nQ_follower = zeros(4, 4)\nR = I(2)","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"Define the parameters for the MPC","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"N = 10\ncontrol_bounds = [-2.0, 2.0]\nparams1 = MPCParams(Q_leader, R, system, control_bounds, N, [0.0, 1.0, 0.0, 0.0])\nparams2 = params3 = MPCParams(Q_follower, R, system, control_bounds, N)","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"Define the potential functions","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"q(x) = (x * x - 50)^2","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"p(x) = x2 x4 * x2 x4 + q(x1 x3)","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"q(x) = (x' * x - 5.0)^2\np(x) = [x[2], x[4]]' * [x[2], x[4]] + q([x[1], x[3]])","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"Define the constant sheaf","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"c = PotentialSheaf([4, 4, 4], [2, 2, 2], [q, q, q])\nset_edge_maps!(c, 1, 2, 1, C, C)\nset_edge_maps!(c, 1, 3, 2, C, C)\nset_edge_maps!(c, 2, 3, 3, C, C)","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"Set up solver to perform MPC and solve the optimization problem with ADMM","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"x_init = BlockArray(rand(12), c.vertex_stalks)\nprob = MultiAgentMPCProblem([params1, params1, params1], c, x_init)\nalg = NonConvexADMM(1000.0, 10, 0.0001, 5000)\nnum_iters = 200","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"Run solver on MPC","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"trajectory, controls = do_mpc!(prob, alg, num_iters)","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"Plot results","category":"page"},{"location":"generated/flocking_example/","page":"Flocking Example","title":"Flocking Example","text":"PaperPlotting.plot_trajectories(trajectory, C)","category":"page"},{"location":"generated/sheaf_macro/#Cellular-Sheaf-DSL","page":"-","title":"Cellular Sheaf DSL","text":"","category":"section"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"Here, we will illustrate how to create a cellular sheaf with the @cellular_sheaf macro.","category":"page"},{"location":"generated/sheaf_macro/#Introduction","page":"-","title":"Introduction","text":"","category":"section"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"The Cellular Sheaf macro allows users to construct a cellular sheaf object. This implies that we can create a graph structure G(V,E) where V = Vertices and E = Edges in the graph \"G\". Then we can create a sheaf object on top of this graph where we can denote the following:","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"Vertex Stalks and their respective dimensions.\nEdge Stalks and their respective dimensions.\nRestriction Maps defined by matrices.","category":"page"},{"location":"generated/sheaf_macro/#Key-Components","page":"-","title":"Key Components","text":"","category":"section"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"The Cellular Sheaf macro allows a user to declare the following:","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"Restriction Maps: A user can define numerous restriction maps outside of the embedded DSL. Restriction maps are defined as Julia matrices:","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":" - ```A = [1 0 0; 0 0 1]```","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"Vertex Stalks: A user can define numerous vertex stalks by declaring a variable a Stalk type in their variable declarations. To complete a Stalk type, the user must also specify the dimension of the given vector space. This can be done by specifying a digit within brackets after the type annotation:","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":" - ```Stalk{1}``` where ```1``` specifies the dimension of the vector space.\n- To complete your vertex stalk, assign your typing to a variable name of choice such as ```vertex_name::Stalk{1}```.","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"Graph Edges: Now that we have declared our restriction maps and our vertex stalks, what can we do with them? We can declare a system of linear equations that represents the relationships or edges between vertices.","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"-  Let us say we are given restriction maps: A and B. Additionally, we are given vertex stalks x and y. We want to create an edge between x and y where the two incident vertices share an edge stalk vector space. We will need to map our given vertex stalks into the edge stalk vector space through our restriction maps: A and B. Given that A maps x to the shared edge space and B maps y to the shared edge space, we yield the following relation:\n\t- ```A(x) == B(y)```: This declares an edge with incident vertex stalks x and y where A maps x to the shared edge space and B maps y to the shared edge space.","category":"page"},{"location":"generated/sheaf_macro/#Putting-It-All-Together","page":"-","title":"Putting It All Together","text":"","category":"section"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"Now that we understand the different components of building a cellular sheaf within our DSL, let's create our very own cellular sheaf.","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"First, let's import necessary modules:","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"using AlgebraicOptimization","category":"page"},{"location":"generated/sheaf_macro/#Triangular-Sheaf","page":"-","title":"Triangular Sheaf","text":"","category":"section"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"Given the following graph: G(V, E) where:","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"V = {x, y, z}\nE = {[x -> y], [x -> z], [y -> z]}","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"We aim to create a cellular sheaf where x, y, and z are vertex stalks of dimension 4.","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"Furthermore, we want to establish each edge stalk with a dimension of 1. To map our vertex stalk to our edge stalk, we will need a 1 x 4 matrix for each. We can define these as A, B, C with arbitrary values since we are more concerned with the relationships than the information in this guide. The information such as feature vectors and mappings are up to the end user.","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"To create the restriction maps, we create Julia matrices as we normally would:","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"A = [1 0 0 0]\nB = [1 0 0 0]\nC = [1 0 0 0]","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"We can then pass these values into our macro as arguments as follows:","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"sheaf = @cellular_sheaf A, B, C begin end","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"This will essentially declare these restriction maps within our cellular sheaf.","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"Now, let's declare our vertex stalks and their respective dimensions. We stated that we want to declare vertex stalks of dimension 4. We can do so within our macro scope as follows:","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"sheaf = @cellular_sheaf A, B, C begin\n  x::Stalk{4}, y::Stalk{4}, z::Stalk{4}\nend","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"Great, now we want to declare our edges in the graph as well as our relationship between our restriction maps and vertex stalks. We can do this using the relationship structure illustrated earlier:","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"sheaf = @cellular_sheaf A, B, C begin\n    x::Stalk{4}, y::Stalk{4}, z::Stalk{4}\n    A(x) == B(y)\n    A(x) == C(z)\n    B(y) == C(z)\nend","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"This establishes three edges within our graph.","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"An edge from x to y with restriction maps A and B.\nAn edge from x to z with restriction maps A and C.\nAn edge from y to z with restriction maps B and C.","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"To conclude, a complete triangular cellular sheaf would look as follows:","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"A = [1 0 1 0]\nB = [1 0 0 1]\nC = [1 0 0 0]\n\nmacro_result = @cellular_sheaf A, B, C begin\n    x::Stalk{4}, y::Stalk{4}, z::Stalk{4}\n\n    A(x) == B(y)\n    A(x) == C(z)\n    B(y) == C(z)\n\nend","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"This translates to these lower-level functions:","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"sheaf = CellularSheaf([4, 4, 4], [1, 1, 1])\nset_edge_maps!(sheaf, 1, 2, 1, A, B)\nset_edge_maps!(sheaf, 1, 3, 2, A, C)\nset_edge_maps!(sheaf, 2, 3, 3, B, C)","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"which generates this sheaf object:","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"sheaf","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"Inferred Edge Stalks: You may be wondering what happened to declaring edge stalks? Because restriction maps and vertex stalks are enough to infer the edge stalks dimensions, the end user does not need to worry about declaring edge stalks. They can focus on solely restriction maps and vertex stalks, minimizing potential errors form wrongly defined edge stalk dimensions.","category":"page"},{"location":"generated/sheaf_macro/#Potential-Exceptions","page":"-","title":"Potential Exceptions","text":"","category":"section"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"\"No restriction maps were passed into the macro.\"","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"- The macro expects at least one restriction map input. This error implies you are trying to create a cellular sheaf with zero restriction maps.","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"\"Restriction map ... is not a matrix\"","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"- The macro expects the inputted restriction map to be a matrix. This error will throw when you attempt to pass in a restriction map that is not a matrix.","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"\"Variable declaration: ... format is invalid\"","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"- Indicates that the inputted declaration did not match expected declaration format.","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"\"Term ... is an invalid product. A product is of form A*x or A(x).\"","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"-  Indicates the LHS or RHS of the equation was not a valid product or function of restriction map and vertex stalk.","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"\"Line is malformed\"","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"- This is a more general parsing error stating that your inputted line of code did not parse as a declaration or an equation.","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"\"Variable type ... is unsupported. Current types include: \"Stalk\" (Vertex Stalk).\"","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"- Indicates you attempted to declare a variable with an undefined type.","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"\"Variable: ... has already been declared.\"","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"- Indicates you are attempting to redeclare a variable. This is not allowed.","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"\"Inferred edge stalk on relation: Ax = By\" is inconsistent. Left restriction map maps dimension ... to dimension ... . Right restriction map maps dimension ... to dimension ... .\"","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"- Indicates that the there is no possible edge stalk value to be inferred based on the restriction map and vertex values you declared.","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"\"Left/Right restriction map (Size: ...) cannot map left/right vertex stalk (Dimension: ...).\"","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"- Implies the restriction map vector space and vertex stalk vector space can not be multiplied.","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"\"Restriction map \"...\" in \", Ax = By\" is undefined.\"","category":"page"},{"location":"generated/sheaf_macro/","page":"-","title":"-","text":"- The restriction map used in the given equation was never declared.","category":"page"},{"location":"generated/moving_formation_example/#Moving-Formation-Example","page":"Moving Formation Example","title":"Moving Formation Example","text":"","category":"section"},{"location":"generated/moving_formation_example/","page":"Moving Formation Example","title":"Moving Formation Example","text":"This example combines a formation goal in positions with a consensus goal in velocities. As such, the coordination sheaf is the constant sheaf underlineR^4 on the three vertex path graph. This encodes a leader-follower topology with the middle agent in the path acting as the leader. The leader’s objective is to track a constant rightward velocity vector and minimize its control actuation while the followers’ objectives are to simply minimize control actuation. The edge potential functions are of the form U_e(y)=(12)y-b_e_2^2 where the velocity coordinates of each be are 0 encoding consensus in velocity while the position coordinates are chosen to achieve a fixed displacement between the leader and its followers. The results of this controller run for 160 iterations are shown below.","category":"page"},{"location":"generated/moving_formation_example/","page":"Moving Formation Example","title":"Moving Formation Example","text":"using Test\nusing AlgebraicOptimization\nusing LinearAlgebra\nusing BlockArrays\nusing Plots\ninclude(\"../../../examples/paper-examples/PaperPlotting.jl\")\nusing .PaperPlotting","category":"page"},{"location":"generated/moving_formation_example/","page":"Moving Formation Example","title":"Moving Formation Example","text":"Set up each agent's dynamics: x(t+1) = Ax(t) + Bu(t)","category":"page"},{"location":"generated/moving_formation_example/","page":"Moving Formation Example","title":"Moving Formation Example","text":"dt = 0.1 # Discretization step size\nA = [1 dt 0 0; 0 1 0 0; 0 0 1 dt; 0 0 0 1]\nB = [0 0; dt 0; 0 0; 0 dt]\nC = [1 0 0 0; 0 0 1 0]\nsystem = DiscreteLinearSystem(A, B, C)","category":"page"},{"location":"generated/moving_formation_example/","page":"Moving Formation Example","title":"Moving Formation Example","text":"Initialize the weight matrices such that the objective only concerns velocities","category":"page"},{"location":"generated/moving_formation_example/","page":"Moving Formation Example","title":"Moving Formation Example","text":"Q_leader = [0 0 0 0; 0 50 0 0; 0 0 0 0; 0 0 0 50]\nQ_follower = zeros(4, 4)\nR = I(2)","category":"page"},{"location":"generated/moving_formation_example/","page":"Moving Formation Example","title":"Moving Formation Example","text":"Define the parameters for the MPC","category":"page"},{"location":"generated/moving_formation_example/","page":"Moving Formation Example","title":"Moving Formation Example","text":"N = 10\ncontrol_bounds = [-2.0, 2.0]\nparams1 = MPCParams(Q_leader, R, system, control_bounds, N, [0.0, 3.0, 0.0, 0.0]) # track this velocity\nparams2 = params3 = MPCParams(Q_follower, R, system, control_bounds, N)","category":"page"},{"location":"generated/moving_formation_example/","page":"Moving Formation Example","title":"Moving Formation Example","text":"Define the constant sheaf","category":"page"},{"location":"generated/moving_formation_example/","page":"Moving Formation Example","title":"Moving Formation Example","text":"c = CellularSheaf([4, 4, 4], [4, 4])\nset_edge_maps!(c, 1, 2, 1, I(4), I(4))\nset_edge_maps!(c, 1, 3, 2, I(4), I(4))","category":"page"},{"location":"generated/moving_formation_example/","page":"Moving Formation Example","title":"Moving Formation Example","text":"Set up solver to perform MPC and solve the optimization problem with ADMM","category":"page"},{"location":"generated/moving_formation_example/","page":"Moving Formation Example","title":"Moving Formation Example","text":"x_init = BlockArray(5 * rand(-1.0:0.1:1.0, 12), c.vertex_stalks)\nb = [5, 0, 5, 0, -5, 0, 5, 0] # Desired pairwise distance\nprob = MultiAgentMPCProblem([params1, params2, params3], c, x_init, b)\nalg = ADMM(2.0, 10)\nnum_iters = 160","category":"page"},{"location":"generated/moving_formation_example/","page":"Moving Formation Example","title":"Moving Formation Example","text":"Run solver on MPC","category":"page"},{"location":"generated/moving_formation_example/","page":"Moving Formation Example","title":"Moving Formation Example","text":"trajectory, controls = do_mpc!(prob, alg, num_iters)","category":"page"},{"location":"generated/moving_formation_example/","page":"Moving Formation Example","title":"Moving Formation Example","text":"Plot results with triangles","category":"page"},{"location":"generated/moving_formation_example/","page":"Moving Formation Example","title":"Moving Formation Example","text":"PaperPlotting.plot_trajectories(trajectory, C, false, true)","category":"page"},{"location":"#AlgebraicOptimization.jl","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"","category":"section"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"This package is designed for building large optimization problems out of simpler subproblems and automatically compiling them to a distributed solver.","category":"page"},{"location":"#Basic-Usage","page":"AlgebraicOptimization.jl","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"The most simple use of this package is making and solving a composite optimization problem. For example, say we have three subproblems whose objectives are given by some random quadratic cost functions:","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"using AlgebraicOptimization\nusing Catlab\n\n# Problem parameters.\nP = [2.1154  -0.3038   0.368   -1.5728  -1.203\n    -0.3038   1.5697   1.0226   0.159   -0.946\n     0.368    1.0226   1.847   -0.4916  -1.2668\n    -1.5728   0.159   -0.4916   2.2192   1.5315\n    -1.203   -0.946   -1.2668   1.5315   1.9281]\nQ = [0.2456   0.3564  -0.0088\n     0.3564   0.5912  -0.0914\n    -0.0088  -0.0914   0.8774]\nR = [2.0546  -1.333   -0.5263   0.3189\n    -1.333    1.0481  -0.0211   0.2462\n    -0.5263  -0.0211   0.951   -0.7813\n     0.3189   0.2462  -0.7813   1.5813]\n\na = [-0.26, 0.22, 0.09, 0.19, -0.96]\nb = [-0.72, 0.12, 0.41]\nc = [0.55, 0.51, 0.6, -0.61]\n\n# Subproblem objectives.\n# A PrimalObjective wraps an objective function with its input dimension.\nf = PrimalObjective(FinSet(5),x->x'*P*x + a'*x)\ng = PrimalObjective(FinSet(3),x->x'*Q*x + b'*x)\nh = PrimalObjective(FinSet(4),x->x'*R*x + c'*x)","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"Now, to compose these subproblems, we need to make them into open problems. An open problem specifies which components of a problem's domain are open to composition with other problems. We do this as follows:","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"# Make open problems.\n# The first argument is the primal objective we are wrapping, the second argument is a function\n# specifying which components of the objective are exposed. \np1 = Open{PrimalObjective}(FinSet(5), PrimalObjective(FinSet(5),f), FinFunction([2,4], 5))\np2 = Open{PrimalObjective}(FinSet(3), PrimalObjective(FinSet(3),g), id(FinSet(3)))\np3 = Open{PrimalObjective}(FinSet(4), PrimalObjective(FinSet(4),h), FinFunction([1,3,4]))","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"To specify the composition pattern of our subproblems, we use Catlab's relation macro to make an undirected wiring diagram and oapply to compose our subproblems.","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"d = @relation_diagram (x,y,z) begin\n    f(u,x)\n    g(u,w,y)\n    h(u,w,z)\nend\n\ncomposite_prob = oapply(d, [p1,p2,p3])","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"Now, we can solve the composite problem with distributed gradient descent:","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"# Arguments are problem, initial guess, step size, and number of iterations\nsol = solve(composite, repeat([100.0], dom(composite_prob).n), 0.1, 100)","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"Currently, we just support unconstrained and equality constrained problems with plans to add support for inequality constrained and disciplined convex programs.","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"More complete documentation and quality of life improvements are also on the way.","category":"page"},{"location":"","page":"AlgebraicOptimization.jl","title":"AlgebraicOptimization.jl","text":"This package is an implementation of A Compositional Framework for First-Order Optimization.","category":"page"}]
}
